{% extends "base.html" %}

{% load i18n %}

{% block title %}
  {% if course %}{{ course.title }} -{% endif %}
  {% trans "Live Whiteboard" %}
{% endblock title %}
{% block content %}
  <div class="container mx-auto px-4 py-8">
    <div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg p-6">
      <!-- Header -->
      <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-6">
        <div>
          <h1 class="text-2xl font-bold text-gray-800 dark:text-white mb-2">{% trans "Live Whiteboard" %}</h1>
          {% if course %}<p class="text-gray-600 dark:text-gray-300">{{ course.title }}</p>{% endif %}
          <p class="text-sm text-gray-500 dark:text-gray-400">
            {% if is_teacher %}
              {% trans "You are the teacher - you can draw and clear the board" %}
            {% else %}
              {% trans "You are a student - you can view live changes" %}
            {% endif %}
          </p>
        </div>
        <div class="flex gap-2 mt-4 sm:mt-0">
          <div id="connectionStatus"
               class="px-3 py-1 rounded-full text-sm font-medium">{% trans "Connecting..." %}</div>
          {% if is_teacher %}
            <button id="clearBoard"
                    class="bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded-lg transition duration-200">
              {% trans "Clear Board" %}
            </button>
          {% endif %}
        </div>
      </div>
      <!-- Toolbar -->
      {% if is_teacher %}
        <div class="flex flex-wrap items-center gap-4 mb-4 p-4 bg-gray-100 dark:bg-gray-700 rounded-lg">
          <div class="flex items-center gap-2">
            <label for="toolSelect" class="font-medium text-gray-700 dark:text-gray-300">{% trans "Tool:" %}</label>
            <select id="toolSelect"
                    class="border border-gray-300 dark:border-gray-600 rounded px-2 py-1 bg-white dark:bg-gray-800 text-gray-700 dark:text-gray-300">
              <option value="pen">{% trans "Pen" %}</option>
              <option value="eraser">{% trans "Eraser" %}</option>
              <option value="highlighter">{% trans "Highlighter" %}</option>
              <option value="line">{% trans "Line" %}</option>
              <option value="rectangle">{% trans "Rectangle" %}</option>
              <option value="circle">{% trans "Circle" %}</option>
              <option value="text">{% trans "Text" %}</option>
              <option value="arrow">{% trans "Arrow" %}</option>
            </select>
          </div>
          <div class="flex items-center gap-2">
            <label for="penColor" class="font-medium text-gray-700 dark:text-gray-300">{% trans "Color:" %}</label>
            <input type="color"
                   id="penColor"
                   value="#000000"
                   class="border border-gray-300 dark:border-gray-600 rounded w-10 h-8" />
          </div>
          <div class="flex items-center gap-2">
            <label for="penWidth" class="font-medium text-gray-700 dark:text-gray-300">{% trans "Width:" %}</label>
            <input type="range" id="penWidth" min="1" max="10" value="2" class="w-24" />
            <span id="penWidthValue" class="text-sm text-gray-600 dark:text-gray-400">2</span>
          </div>
          <div class="flex items-center gap-2">
            <label for="imageScale" class="font-medium text-gray-700 dark:text-gray-300">{% trans "Image Scale:" %}</label>
            <input type="range"
                   id="imageScale"
                   min="10"
                   max="300"
                   value="100"
                   class="w-24" />
            <span id="imageScaleValue" class="text-sm text-gray-600 dark:text-gray-400">100%</span>
          </div>
          <button id="uploadBoard"
                  class="px-4 py-2 bg-indigo-600 hover:bg-indigo-700 text-white rounded transition duration-200">
            {% trans "Load Image" %}
          </button>
          <input type="file" id="loadInput" accept="image/*" style="display: none;" />
          <button id="downloadBoard"
                  class="px-4 py-2 bg-purple-600 hover:bg-purple-700 text-white rounded transition duration-200">
            {% trans "Download" %}
          </button>
        </div>
      {% endif %}
      <!-- Canvas Container -->
      <div class="overflow-auto border border-gray-300 dark:border-gray-600 rounded-lg">
        <canvas id="whiteboard"
                class="block"
                width="1200"
                height="800"
                style="background-color: white">
          {% trans "Your browser does not support the HTML5 canvas." %}
        </canvas>
      </div>
      <!-- Active Users -->
      <div class="mt-4 p-4 bg-gray-100 dark:bg-gray-700 rounded-lg">
        <h3 class="text-lg font-medium text-gray-800 dark:text-white mb-2">{% trans "Active Users" %}</h3>
        <div id="activeUsers" class="flex flex-wrap gap-2">
          <!-- Users will be populated via WebSocket -->
        </div>
      </div>
      <!-- Config Data (hidden) -->
      <div id="whiteboardConfig"
           class="hidden"
           data-room-name="{{ room_name }}"
           data-classroom-id="{{ classroom_id }}"
           data-is-teacher="{{ is_teacher|yesno:'true,false' }}"></div>
      <!-- Back Button -->
      <div class="mt-6">
        <a href="{% url 'virtual_classroom_detail' classroom.id %}"
           class="bg-gray-500 hover:bg-gray-600 text-white px-6 py-2 rounded-lg transition duration-200">
          {% trans "Back to Classroom" %}
        </a>
      </div>
    </div>
  </div>
  <script>
      // WebSocket and Canvas Configuration
      const configEl = document.getElementById('whiteboardConfig');
      const roomName = configEl.dataset.roomName;
      const classroomId = parseInt(configEl.dataset.classroomId, 10);
      const isTeacher = configEl.dataset.isTeacher === 'true';
      const wsScheme = window.location.protocol === 'https:' ? 'wss' : 'ws';
      const wsPath = `${wsScheme}://${window.location.host}/ws/whiteboard/${roomName}/`;
      // Canvas setup
      const canvas = document.getElementById('whiteboard');
      const ctx = canvas.getContext('2d');
      let drawing = false;
      let startX = 0;
      let startY = 0;
      let snapshot = null;
      let uploadedImage = null;

      // Tool settings
      let currentTool = 'pen';
      let penColor = '#000000';
      let penWidth = 2;
      let imageScale = 1.0;

      // WebSocket connection
      let socket = null;
      let reconnectAttempts = 0;
      const maxReconnectAttempts = 5;

      // Initialize
      document.addEventListener('DOMContentLoaded', function() {
          initializeCanvas();
          connectWebSocket();
          loadWhiteboardData();

          if (isTeacher) {
              setupTeacherControls();
          }
      });

      function initializeCanvas() {
          // Set canvas background
          ctx.fillStyle = 'white';
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // Setup drawing event listeners
          if (isTeacher) {
              canvas.addEventListener('mousedown', startDrawing);
              canvas.addEventListener('mousemove', draw);
              canvas.addEventListener('mouseup', stopDrawing);
              canvas.addEventListener('mouseleave', stopDrawing);

              // Touch events for mobile
              canvas.addEventListener('touchstart', handleTouchStart);
              canvas.addEventListener('touchmove', handleTouchMove);
              canvas.addEventListener('touchend', handleTouchEnd);
          }
      }

      function setupTeacherControls() {
          // Tool selection
          const toolSelect = document.getElementById('toolSelect');
          const penColorInput = document.getElementById('penColor');
          const penWidthInput = document.getElementById('penWidth');
          const imageScaleInput = document.getElementById('imageScale');
          const uploadBtn = document.getElementById('uploadBoard');
          const loadInput = document.getElementById('loadInput');
          const downloadBtn = document.getElementById('downloadBoard');
          const clearBtn = document.getElementById('clearBoard');

          toolSelect.addEventListener('change', function() {
              currentTool = this.value;
              if (currentTool === 'highlighter') {
                  ctx.globalAlpha = 0.3;
              } else {
                  ctx.globalAlpha = 1.0;
              }
          });

          penColorInput.addEventListener('change', function() {
              penColor = this.value;
          });

          penWidthInput.addEventListener('input', function() {
              penWidth = parseInt(this.value, 10);
              document.getElementById('penWidthValue').textContent = penWidth;
          });

          imageScaleInput.addEventListener('input', function() {
              imageScale = parseInt(this.value, 10) / 100;
              document.getElementById('imageScaleValue').textContent = this.value + '%';
              if (uploadedImage) {
                  redrawBackground();
              }
          });

          uploadBtn.addEventListener('click', () => loadInput.click());

          loadInput.addEventListener('change', handleImageUpload);

          downloadBtn.addEventListener('click', downloadCanvas);

          clearBtn.addEventListener('click', clearWhiteboard);
      }

      function startDrawing(e) {
          if (!isTeacher) return;

          drawing = true;
          const rect = canvas.getBoundingClientRect();
          startX = e.clientX - rect.left;
          startY = e.clientY - rect.top;

          if (currentTool === 'pen' || currentTool === 'eraser' || currentTool === 'highlighter') {
              ctx.beginPath();
              ctx.moveTo(startX, startY);
          } else if (currentTool === 'text') {
              const text = prompt("Enter text to add:");
              if (text) {
                  ctx.font = `${penWidth * 5}px sans-serif`;
                  ctx.fillStyle = penColor;
                  ctx.fillText(text, startX, startY);
                  broadcastCanvasData();
              }
              drawing = false;
          } else {
              takeSnapshot();
          }
      }

      function draw(e) {
          if (!drawing || !isTeacher) return;

          const rect = canvas.getBoundingClientRect();
          const currentX = e.clientX - rect.left;
          const currentY = e.clientY - rect.top;

          if (currentTool === 'pen' || currentTool === 'eraser' || currentTool === 'highlighter') {
              ctx.lineWidth = penWidth;

              if (currentTool === 'eraser') {
                  ctx.strokeStyle = "#FFFFFF";
                  ctx.globalAlpha = 1.0;
              } else if (currentTool === 'pen') {
                  ctx.strokeStyle = penColor;
                  ctx.globalAlpha = 1.0;
              } else if (currentTool === 'highlighter') {
                  ctx.strokeStyle = penColor;
                  ctx.globalAlpha = 0.3;
              }

              ctx.lineTo(currentX, currentY);
              ctx.stroke();

              // Broadcast drawing data in real-time
              broadcastDrawingAction({
                  type: 'draw',
                  tool: currentTool,
                  color: penColor,
                  width: penWidth,
                  x: currentX,
                  y: currentY,
                  startX: startX,
                  startY: startY
              });
          } else {
              // Preview mode for shapes
              restoreSnapshot();
              ctx.lineWidth = penWidth;
              ctx.strokeStyle = penColor;

              if (currentTool === 'line') {
                  ctx.beginPath();
                  ctx.moveTo(startX, startY);
                  ctx.lineTo(currentX, currentY);
                  ctx.stroke();
              } else if (currentTool === 'rectangle') {
                  const width = currentX - startX;
                  const height = currentY - startY;
                  ctx.strokeRect(startX, startY, width, height);
              } else if (currentTool === 'circle') {
                  const radius = Math.sqrt(Math.pow(currentX - startX, 2) + Math.pow(currentY - startY, 2));
                  ctx.beginPath();
                  ctx.arc(startX, startY, radius, 0, Math.PI * 2);
                  ctx.stroke();
              } else if (currentTool === 'arrow') {
                  drawArrow(startX, startY, currentX, currentY);
              }
          }
      }

      function stopDrawing(e) {
          if (!drawing || !isTeacher) return;

          drawing = false;

          if (currentTool !== 'pen' && currentTool !== 'eraser' && currentTool !== 'highlighter') {
              const rect = canvas.getBoundingClientRect();
              const currentX = e.clientX - rect.left;
              const currentY = e.clientY - rect.top;

              // Finalize shapes
              restoreSnapshot();
              ctx.lineWidth = penWidth;
              ctx.strokeStyle = penColor;

              if (currentTool === 'line') {
                  ctx.beginPath();
                  ctx.moveTo(startX, startY);
                  ctx.lineTo(currentX, currentY);
                  ctx.stroke();
              } else if (currentTool === 'rectangle') {
                  const width = currentX - startX;
                  const height = currentY - startY;
                  ctx.strokeRect(startX, startY, width, height);
              } else if (currentTool === 'circle') {
                  const radius = Math.sqrt(Math.pow(currentX - startX, 2) + Math.pow(currentY - startY, 2));
                  ctx.beginPath();
                  ctx.arc(startX, startY, radius, 0, Math.PI * 2);
                  ctx.stroke();
              } else if (currentTool === 'arrow') {
                  drawArrow(startX, startY, currentX, currentY);
              }
          }

          // Broadcast final canvas state
          broadcastCanvasData();
      }

      // Touch event handlers for mobile
      function handleTouchStart(e) {
          e.preventDefault();
          const touch = e.touches[0];
          const mouseEvent = new MouseEvent('mousedown', {
              clientX: touch.clientX,
              clientY: touch.clientY
          });
          canvas.dispatchEvent(mouseEvent);
      }

      function handleTouchMove(e) {
          e.preventDefault();
          const touch = e.touches[0];
          const mouseEvent = new MouseEvent('mousemove', {
              clientX: touch.clientX,
              clientY: touch.clientY
          });
          canvas.dispatchEvent(mouseEvent);
      }

      function handleTouchEnd(e) {
          e.preventDefault();
          const mouseEvent = new MouseEvent('mouseup', {});
          canvas.dispatchEvent(mouseEvent);
      }

      function handleImageUpload(event) {
          const file = event.target.files[0];
          if (!file) return;

          const reader = new FileReader();
          reader.onload = function(e) {
              const dataURL = e.target.result;
              const img = new Image();
              img.src = dataURL;
              img.onload = function() {
                  uploadedImage = img;
                  redrawBackground();
                  broadcastCanvasData();
              };
          };
          reader.readAsDataURL(file);
      }

      function redrawBackground() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = 'white';
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          if (uploadedImage) {
              const newWidth = uploadedImage.width * imageScale;
              const newHeight = uploadedImage.height * imageScale;
              ctx.drawImage(uploadedImage, 0, 0, newWidth, newHeight);
          }
      }

      function downloadCanvas() {
          const dataURL = canvas.toDataURL("image/png");
          const link = document.createElement('a');
          link.href = dataURL;
          link.download = "whiteboard.png";
          link.click();
      }

      function clearWhiteboard() {
          if (!isTeacher) return;

          if (confirm('{% trans "Are you sure you want to clear the whiteboard? This action cannot be undone." %}')) {
              // Clear the canvas locally
              clearCanvas();

              // Broadcast the clear action to other users via WebSocket
              broadcastClearAction();
          }
      }

      function clearCanvas() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = 'white';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          uploadedImage = null;
      }

      function takeSnapshot() {
          snapshot = ctx.getImageData(0, 0, canvas.width, canvas.height);
      }

      function restoreSnapshot() {
          if (snapshot) {
              ctx.putImageData(snapshot, 0, 0);
          }
      }

      function drawArrow(fromX, fromY, toX, toY) {
          const headlen = 10;
          const angle = Math.atan2(toY - fromY, toX - fromX);

          ctx.beginPath();
          ctx.moveTo(fromX, fromY);
          ctx.lineTo(toX, toY);
          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(toX, toY);
          ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6));
          ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6));
          ctx.lineTo(toX, toY);
          ctx.stroke();
      }

      // WebSocket functions
      function connectWebSocket() {
          socket = new WebSocket(wsPath);

          socket.onopen = function(e) {
              console.log('WebSocket connection established');
              updateConnectionStatus(true);
              reconnectAttempts = 0;
          };

          socket.onmessage = function(e) {
              const data = JSON.parse(e.data);
              handleWebSocketMessage(data);
          };

          socket.onclose = function(e) {
              console.log('WebSocket connection closed');
              updateConnectionStatus(false);

              // Attempt to reconnect
              if (reconnectAttempts < maxReconnectAttempts) {
                  setTimeout(() => {
                      reconnectAttempts++;
                      connectWebSocket();
                  }, 2000 * reconnectAttempts);
              }
          };

          socket.onerror = function(e) {
              console.error('WebSocket error:', e);
              updateConnectionStatus(false);
          };
      }

      function handleWebSocketMessage(data) {
          switch (data.type) {
              case 'canvas_update':
                  loadCanvasFromData(data.canvas_data, data.background_image);
                  break;
              case 'drawing_action':
                  applyDrawingAction(data.action);
                  break;
              case 'clear_board':
                  clearCanvas();
                  break;
              case 'user_joined':
              case 'user_left':
                  updateActiveUsers(data.users);
                  break;
          }
      }

      function broadcastCanvasData() {
          if (socket && socket.readyState === WebSocket.OPEN) {
              const canvasData = canvas.toDataURL();
              socket.send(JSON.stringify({
                  type: 'canvas_update',
                  canvas_data: canvasData,
                  background_image: uploadedImage ? uploadedImage.src : ''
              }));
          }
      }

      function broadcastDrawingAction(action) {
          if (socket && socket.readyState === WebSocket.OPEN) {
              socket.send(JSON.stringify({
                  type: 'drawing_action',
                  action: action
              }));
          }
      }

      function broadcastClearAction() {
          if (socket && socket.readyState === WebSocket.OPEN) {
              socket.send(JSON.stringify({
                  type: 'clear_board'
              }));
          }
      }

      function loadCanvasFromData(canvasData, backgroundImage) {
          if (canvasData) {
              const img = new Image();
              img.onload = function() {
                  ctx.clearRect(0, 0, canvas.width, canvas.height);
                  ctx.drawImage(img, 0, 0);
              };
              img.src = canvasData;
          }

          if (backgroundImage) {
              const bgImg = new Image();
              bgImg.onload = function() {
                  uploadedImage = bgImg;
              };
              bgImg.src = backgroundImage;
          }
      }

      function applyDrawingAction(action) {
          // Apply real-time drawing actions from other users
          if (action.type === 'draw') {
              ctx.lineWidth = action.width;
              ctx.strokeStyle = action.color;

              if (action.tool === 'eraser') {
                  ctx.strokeStyle = "#FFFFFF";
                  ctx.globalAlpha = 1.0;
              } else if (action.tool === 'highlighter') {
                  ctx.globalAlpha = 0.3;
              } else {
                  ctx.globalAlpha = 1.0;
              }

              ctx.lineTo(action.x, action.y);
              ctx.stroke();
          }
      }

      function updateConnectionStatus(connected) {
          const statusElement = document.getElementById('connectionStatus');
          if (connected) {
              statusElement.textContent = '{% trans "Connected" %}';
              statusElement.className = 'px-3 py-1 rounded-full text-sm font-medium bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200';
          } else {
              statusElement.textContent = '{% trans "Disconnected" %}';
              statusElement.className = 'px-3 py-1 rounded-full text-sm font-medium bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200';
          }
      }

      function updateActiveUsers(users) {
          const activeUsersElement = document.getElementById('activeUsers');
          activeUsersElement.innerHTML = '';

          users.forEach(user => {
              const userElement = document.createElement('div');
              userElement.className = 'px-3 py-1 bg-teal-100 dark:bg-teal-900 text-teal-800 dark:text-teal-200 rounded-full text-sm';
              userElement.textContent = user.username;
              activeUsersElement.appendChild(userElement);
          });
      }

      function loadWhiteboardData() {
          fetch(`/whiteboard/${classroomId}/data/`, {
                  method: 'GET',
                  headers: {
                      'X-CSRFToken': csrftoken
                  },
                  credentials: 'same-origin'
              })
              .then(response => response.json())
              .then(data => {
                  if (data.canvas_data && data.canvas_data.length > 0) {
                      loadCanvasFromData(data.canvas_data, data.background_image);
                  }
              })
              .catch(error => {
                  console.error('Error loading whiteboard data:', error);
              });
      }

      function getCookie(name) {
          let cookieValue = null;
          if (document.cookie && document.cookie !== '') {
              const cookies = document.cookie.split(';');
              for (let i = 0; i < cookies.length; i++) {
                  const cookie = cookies[i].trim();
                  if (cookie.substring(0, name.length + 1) === (name + '=')) {
                      cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                      break;
                  }
              }
          }
          return cookieValue;
      }

      // Get CSRF token for secure AJAX requests
      const csrftoken = getCookie('csrftoken');

      // Helper function for making secure AJAX requests with CSRF protection
      function makeSecureRequest(url, method, data = null) {
          const headers = {
              'Content-Type': 'application/json',
              'X-CSRFToken': csrftoken
          };

          const options = {
              method: method,
              headers: headers,
              credentials: 'same-origin' // Include cookies for CSRF token
          };

          if (data && (method === 'POST' || method === 'PUT' || method === 'PATCH')) {
              options.body = JSON.stringify(data);
          }

          return fetch(url, options);
      }

      // Example functions for making secure requests to whiteboard endpoints (if needed)
      function saveWhiteboardDataSecure(canvasData, backgroundImage) {
          if (!isTeacher) return Promise.reject('Only teachers can save whiteboard data');

          return makeSecureRequest(`/whiteboard/${classroomId}/save/`, 'POST', {
              canvas_data: canvasData,
              background_image: backgroundImage || ''
          });
      }

      function clearWhiteboardSecure() {
          if (!isTeacher) return Promise.reject('Only teachers can clear whiteboard');

          return makeSecureRequest(`/whiteboard/${classroomId}/clear/`, 'POST');
      }
  </script>
{% endblock content %}
